var documenterSearchIndex = {"docs":
[{"location":"#ddHodge","page":"Home","title":"ddHodge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ddHodge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#ddHodge.ddhResult","page":"Home","title":"ddHodge.ddhResult","text":"Container of the workflow results. See ddHodgeWorkflow for details.\n\n\n\n\n\n","category":"type"},{"location":"#ddHodge.alignSpaces-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{<:AbstractMatrix}}","page":"Home","title":"ddHodge.alignSpaces","text":"alignSpaces(graph, subspaces) -> (alignedSpaces, sheafGrad, restrictionMaps)\n\nSolves subspace alignment problem by minimizing Rayleigh quotient of sheaf (connection) laplacian Delta_s\n\nmin_bm x sum_(uv) in E O_u bm x_u - O_v bm x_v^2 = bm x^top Delta_s bm x\n\nwhere O_u O_v are the restriction maps of parallel transport matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.basischange-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.basischange","text":"basischange(A, V, W) -> B::Matrix\n\nChange of basis: the matrix A in the basis V into the basis W\n\nwarning: Warning\nUse with caution when span(V) ≠ span(W).\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.basischange-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.basischange","text":"basischange(A, V) -> B::Matrix\n\nChange of basis: A in the basis V into the canonical basis, i.e., W = I\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.ddHodgeWorkflow-Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.ddHodgeWorkflow","text":"ddHodgeWorkflow(g, X, V;\n    rdim=size(X,1)::Int, λ=0.1, ϵ=0.1,\n    ssa=true, ssart=1, krytol=1e-32, useCUDA=false\n) -> ddh::ddhResult\n\nddHodge standard workflow\n\nArguments\n\nRequired \n\ng::SimpleGraph: undirected graph of N vertices.\nX::AbstractMatrix: the matrices of data points.\nV::AbstractMatrix: the matrices of velocites at the points.\n\nThese matrices X and V should be in the same size of M variables (rows) x N samples (columns) and the order of columns should correspond to the vertex order of g.\n\nOptional\n\nrdim::Int: the dimension of the tangent space. The default is M (no reduction).\nλ::Float64=0.1: the regularization parameter for Hessian estimation.\nϵ::Float64=0.1: the regularization parameter for Jacobian estimation.\nssa::Bool=true: the flag of peforming subspace (axis) alignment.\nssart::Int=1: the reference node of axis alignment.\nkrytol::Float64=1e-32: the tolerance for Krylov solver.\nuseCUDA::Bool=false: the flag for GPU acceleration.\n\nOutput\n\nThe returned ddh::ddhResult consists of the following fields.\n\nVertex-level features\n\nddh.u: potential\nddh.div: divergence\nddh.rot: rotation (curl)\nddh.vgrass: Grassmann distance (averaged at vertices)\nddh.spans: local PCA tangent spaces\nddh.frames: axes-aligned local PCA spaces\nddh.planes: PC1-2 tangent planes\nddh.H: reconstructed Hessian matrices (in ddh.frames)\nddh.J: reconstructed Jacobian matrices (in ddh.frames)\n\nEdge-level features\n\nddh.w: edge weight\nddh.egrass: Grassmann distance\nddh.rmaps: restriction maps\n\nOperaters\n\nddh.d0: gradient operator\nddh.d0s: sheaf version of gradient operator\n\nThe order of these values is consistent with the vertex/edge order of given graph g.\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.graphgrad-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Home","title":"ddHodge.graphgrad","text":"graphgrad(g)\n\nConstruct grad operator from graph g\n\nThe direction is implicitly determined by node order, i.e., i -> j if i < j.\n\nExample\n\njulia> using ddHodge.Graphs\n\njulia> g = complete_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> collect(edges(g))\n3-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 3\n\njulia> d0 = ddHodge.graphgrad(g)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n -1.0   1.0   ⋅ \n -1.0    ⋅   1.0\n   ⋅   -1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.kNNGraph-Tuple{AbstractMatrix, Int64}","page":"Home","title":"ddHodge.kNNGraph","text":"kNNGraph(X::Matrix, k::Int) -> (g::SimpleGraph, kdtree::KDTree)\n\nGraph construction using k-NN\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.schurselect-Tuple{LinearAlgebra.Schur, Vector{Int64}}","page":"Home","title":"ddHodge.schurselect","text":"schurselect(F::Schur, idx::Vector{Int}) -> (values, Z::Matrix)\n\nReturns the basis of invariant subspace Z; the columns are the selected Schur vectors specified by idx.\n\nwarning: Warning\nThe invariance is guaranteed if the conjugate pair of the complex eigenvalues were selected.\n\nExample\n\njulia> using ddHodge.LinearAlgebra: schur\n\njulia> A = [0 1 0; -1 0 0; 0 0 1]\n3×3 Matrix{Int64}:\n  0  1  0\n -1  0  0\n  0  0  1\n\njulia> F = schur(A);\n\njulia> i, j, = sortperm(abs.(imag.(F.values)),rev=true);\n\njulia> vals, Z = schurselect(F,[i,j]) # x-y plane is the invariant of A \n(values = ComplexF64[0.0 + 1.0im, 0.0 - 1.0im], Z = [1.0 0.0; 0.0 1.0; 0.0 0.0])\n\n\n\n\n\n","category":"method"}]
}

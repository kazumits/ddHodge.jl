var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ddHodge","category":"page"},{"location":"#ddHodge","page":"Home","title":"ddHodge","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ddHodge.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ddHodge]","category":"page"},{"location":"#ddHodge.ddhResult","page":"Home","title":"ddHodge.ddhResult","text":"Container of the workflow results\n\n\n\n\n\n","category":"type"},{"location":"#ddHodge.alignSpaces-Tuple{Graphs.SimpleGraphs.SimpleGraph, Vector{<:AbstractMatrix}}","page":"Home","title":"ddHodge.alignSpaces","text":"alignSpaces(graph, subspaces) -> (alignedSpaces, sheafGrad, restrictionMaps)\n\nSolves subspace alignment problem by minimizing Rayleigh quotient of sheaf (connection) laplacian Delta_s\n\nmin_bm x sum_(uv) in E O_u bm x_u - O_v bm x_v^2 = bm x^top Delta_s bm x\n\nwhere O_u O_v are the restriction maps of parallel transport matrix.\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.basischange-Tuple{AbstractMatrix, AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.basischange","text":"basischange(A, V, W) -> B::Matrix\n\nChange of basis: the matrix A in the basis V into the basis W\n\nwarning: Warning\nUse with caution when span(V) ≠ span(W).\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.basischange-Tuple{AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.basischange","text":"basischange(A, V) -> B::Matrix\n\nChange of basis: A in the basis V into the canonical basis, i.e., W = I\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.ddHodgeWorkflow-Tuple{Graphs.SimpleGraphs.SimpleGraph, AbstractMatrix, AbstractMatrix}","page":"Home","title":"ddHodge.ddHodgeWorkflow","text":"ddHodgeWorkflow(g, X, V;\n    rdim=size(X,1)::Int, λ=0.1, ϵ=0.1,\n    ssa=true, ssart=1, krytol=1e-32, useCUDA=false\n) -> ddh::ddhResult\n\nddHodge standard workflow\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.graphgrad-Tuple{Graphs.SimpleGraphs.SimpleGraph}","page":"Home","title":"ddHodge.graphgrad","text":"graphgrad(g)\n\nConstruct grad operator from graph g\n\nThe direction is implicitly determined by node order, i.e., i -> j if i < j.\n\nExample\n\njulia> using ddHodge.Graphs\n\njulia> g = complete_graph(3)\n{3, 3} undirected simple Int64 graph\n\njulia> collect(edges(g))\n3-element Vector{Graphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 3\n\njulia> d0 = ddHodge.graphgrad(g)\n3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 6 stored entries:\n -1.0   1.0   ⋅ \n -1.0    ⋅   1.0\n   ⋅   -1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.kNNGraph-Tuple{AbstractMatrix, Int64}","page":"Home","title":"ddHodge.kNNGraph","text":"kNNGraph(X::Matrix, k::Int) -> (g::SimpleGraph, kdtree::KDTree)\n\nGraph construction using k-NN\n\n\n\n\n\n","category":"method"},{"location":"#ddHodge.schurselect-Tuple{LinearAlgebra.Schur, Vector{Int64}}","page":"Home","title":"ddHodge.schurselect","text":"schurselect(F::Schur, idx::Vector{Int}) -> (values, Z::Matrix)\n\nReturns the basis of invariant subspace Z; the columns are the selected Schur vectors specified by idx.\n\nwarning: Warning\nThe invariance is guaranteed if the conjugate pair of the complex eigenvalues were selected.\n\nExample\n\njulia> using ddHodge.LinearAlgebra: schur\n\njulia> A = [0 1 0; -1 0 0; 0 0 1]\n3×3 Matrix{Int64}:\n  0  1  0\n -1  0  0\n  0  0  1\n\njulia> F = schur(A);\n\njulia> i, j, = sortperm(abs.(imag.(F.values)),rev=true);\n\njulia> vals, Z = schurselect(F,[i,j]) # x-y plane is the invariant of A \n(values = ComplexF64[0.0 + 1.0im, 0.0 - 1.0im], Z = [1.0 0.0; 0.0 1.0; 0.0 0.0])\n\n\n\n\n\n","category":"method"}]
}
